---
title: 虚拟机类加载机制
date: 2017-09-08 09:31:23
tags:
- JVM
- 类加载
comments: true
categories: 原创
---

# 概述
&nbsp;&nbsp;&nbsp;&nbsp;我们都知道，计算机并不能直接读懂我们人所使用的语言，所以我们编写的程序必须转换成计算机能读懂的语言的才能执行。在JAVA的Class文件中描述的各种信息也不例外，最终都需要加载到虚拟机中之后才能运行和使用。而虚拟机如何加载这些Class文件？Class文件中的信息进入到虚拟机后会发生什么变化？这些都是接下来将要说的内容。
<!-- more -->
&nbsp;&nbsp;&nbsp;&nbsp;虚拟机把描述类的数据从Class文件**加载(Loading)**到内存，并对数据进行**连接(Linking)**和**初始化(Initialization)**，其中连接分为 *验证(Verification)*、*准备(Preparation)*、*解析(Resolution)* 三步，最终形成可以被虚拟机直接使用的JAVA类型，这就是虚拟机的**类加载机制**。

---

# 类加载的过程
&nbsp;&nbsp;&nbsp;&nbsp;接下来我们详细说一下JAVA虚拟机中类加载的全过程，也就是**加载**、**验证**、**准备**、**解析**和**初始化**这5个阶段所执行的具体动作。

## 加载
&nbsp;&nbsp;&nbsp;&nbsp;加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下3件事情：

&nbsp;&nbsp;&nbsp;&nbsp;1、通过一个类的全限定名来获取定义此类的二进制字节流。

&nbsp;&nbsp;&nbsp;&nbsp;2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

&nbsp;&nbsp;&nbsp;&nbsp;3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

&nbsp;&nbsp;&nbsp;&nbsp;在这里，第一条中的二进制字节流并不只是单纯的从一个Class文件中获取，他还可以从ZIP包中读取，从网络中获取（最典型的应用：Applet），还可以运算时生成(动态代理技术)等方式。
&nbsp;&nbsp;&nbsp;&nbsp;相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确的说是加载阶段中获取二进制字节流的的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成。
&nbsp;&nbsp;&nbsp;&nbsp;加载阶段与连接阶段的部分内容（一部分字节码文件格式验证动作）是交叉进行的，这两个阶段的开始时间仍然保持着固定的先后顺序。

## 验证
&nbsp;&nbsp;&nbsp;&nbsp;验证是连接阶段的第一步，主要目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全。验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击。从整体上来看，验证阶段大致上分为4个阶段的检验动作：**文件格式验证**、**元数据验证**、**字节码验证**、**符号引用验证**。

&nbsp;&nbsp;&nbsp;&nbsp;**1.文件格式验证**：该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。只有通过了这个阶段的验证后，字节流才会进入内存的方法区中存储，后面3个验证阶段全部是基于方法区的存储结构进行，不会再直接操作字节流。

&nbsp;&nbsp;&nbsp;&nbsp;**2.元数据验证**：这个阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息，此阶段是对元数据信息的**数据类型**进行校验。

&nbsp;&nbsp;&nbsp;&nbsp;**3.字节码验证**：本阶段是整个验证过程中最复杂的一个阶段，主要是通过 ***数据流*** 和 ***控制流*** 分析，确定程序语义是合法的、符合逻辑的。这个阶段将对类的**方法体**进行校验分析。

&nbsp;&nbsp;&nbsp;&nbsp;**4.符号引用验证**：本阶段是验证的最后一个阶段，发生在虚拟机将符号引用转化为直接引用的时候，这个转化将在连接的第三阶段——解析阶段发生。符号引用验证的目的是确保解析动作能正常执行。

## 准备
&nbsp;&nbsp;&nbsp;&nbsp;准备阶段是正式为类变量**分配内存**并**设置类变量初始值**的阶段。这里需要强调一下，首先，这时候进行内存分配的仅包括类变量(被static修饰的变量)，不包括实例变量，实例变量会在对象实例化时伴随对象一起分配在Java堆中。其次，这里的初始值“通常情况”下为数据的零值，看下方的代码：
``` bash
public static int value = 123;
```
这里value在准备阶段过后的初始值是0而不是123，把value赋值为123的动作将在**初始化阶段**才会执行。既然有通常情况，也就会有“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那么准备阶段变量value就会被初始化为ConstantValue属性所指定的值，代码如下：
``` bash
public static final int value = 123;
```
这时，在准备阶段虚拟机会根据ConstantValue的设置将value赋值为123.

## 解析
&nbsp;&nbsp;&nbsp;&nbsp;解析阶段是虚拟机将常量池内的**符号引用**替换为**直接引用(得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法)**的过程。

## 初始化
&nbsp;&nbsp;&nbsp;&nbsp;在**准备**阶段，变量已经赋值过一次系统要求的初始值，而在**初始化阶段**，则根据程序员通过程序制定的主观计划去初始化**类变量**和**其他资源**，举个例子：
```bash
public static int value1 = 2;
public static int value2 = 6;
static{
	value2 = 8;
}
```
在准备阶段，value1和value2都等于0，在初始化阶段value1和value2分别等于2和8。类的初始化阶段就是执行类构造器“**< clinit>()**”方法的过程，该方法只能在类加载的过程中由JVM调用，下面介绍一下< clinit>()的特点和细节：

&nbsp;&nbsp;&nbsp;&nbsp;1、编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量；

&nbsp;&nbsp;&nbsp;&nbsp;2、如果一个类的父类还没有初始化，那么会优先初始化父类，但是< clinit>()方法不会显示地调用父类< clinit>()方法，JVM负责保证一个类的< clinit>()方法执行之前，他父类的< clinit>()方法已经被执行；因此在虚拟机中第一个被执行< clinit>()方法的类一定是java.lang.Object。

&nbsp;&nbsp;&nbsp;&nbsp;3、JVM必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。

&nbsp;&nbsp;&nbsp;&nbsp;4、如果一个类中没有静态语句块，也没有对类变量的进行赋值操作，那么该类可以没有< clinit>()方法。另外，在接口中不需要先执行父接口的< clinit>()方法，只有当父接口中定义的变量被使用时，父接口才会初始化；接口的实现类在初始化时也一样不会执行接口的< clinit>()方法。

**触发初始化的时间：**

&nbsp;&nbsp;&nbsp;&nbsp;1、遇到**new**、**getstatic**、**putstatic**或**invokestatic**这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。

&nbsp;&nbsp;&nbsp;&nbsp;2、使用java.lang.reflect包的方法对类进行反射调用的时候。

&nbsp;&nbsp;&nbsp;&nbsp;3、放初始化一个类的时候，发现其父类还没有进行初始化过，则先初始化父类。

&nbsp;&nbsp;&nbsp;&nbsp;4、当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的类），虚拟机会先初始化这个主类。

&nbsp;&nbsp;&nbsp;&nbsp;5、当使用动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStstic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则先触发初始化。

---

# 其他
&nbsp;&nbsp;&nbsp;&nbsp;Java虚拟机规范中并没有对 什么时候开始类加载过程的**加载阶段** 进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于**初始化阶段**，虚拟机规范则是严格规定了有且只有上文提到的5种情况。

&nbsp;&nbsp;&nbsp;&nbsp;类的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载7个阶段；其中加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的**开始**（不代表进行或完成），但**解析**阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的**运行时绑定**（也称为动态绑定或晚期绑定）。

---
转载请注明出处：[小Hang同学的博客](http://www.yhang6.com/) 