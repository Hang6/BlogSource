---
title: 关于Java虚拟机的垃圾回收
date: 2017-09-05 21:22:35
tags:
- JVM
- 垃圾收集
comments: true
categories: 原创
---

# JVM的内存区域分配
&nbsp;&nbsp;&nbsp;&nbsp;要讲垃圾收集算法，首先需要分清楚JVM的内存区域分配：JVM的运行时数据区可以分为程序计数器（Program Counter Register）、虚拟机栈（VM Stack）、本地方法栈（Native Method Stack）、堆（Heap）、方法区（Method Area）五个部分。其中Sun HotSpot虚拟机将虚拟机栈和本地方法栈合二为一，并且方法区是堆的一个逻辑部分。而我们将要讲到的垃圾回收就是发生在堆中。
<!-- more -->

&nbsp;&nbsp;&nbsp;&nbsp;从垃圾收集的角度讲，HotSpot虚拟机将堆区分为GC堆和方法区，也有人将其分为永生代（方法区）、新生代、老年代，其中新生代和老年代属于GC堆，而新生代又可分为Eden空间和两个Survivior空间。至此，堆区的内存分布大致已经讲清楚了，下面我们将介绍几种垃圾收集算法。

---
# 各垃圾收集算法的含义
## 标记-清除算法
&nbsp;&nbsp;&nbsp;&nbsp;“标记-清除”算法是最基础的收集算法，它分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，标记完成后，统一回收所有标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进而改进得到的。

&nbsp;&nbsp;&nbsp;&nbsp;该方法主要有两个不足：

&nbsp;&nbsp;&nbsp;&nbsp;1.效率问题，标记和清除两个过程的效率都不高

&nbsp;&nbsp;&nbsp;&nbsp;2.空间问题，该方法清除之后会产生大量零散的内存空间，若之后程序遇到需要分配较大对象而内存空间不足时，会提前触发下一次的垃圾收集动作。

## 标记-整理算法
&nbsp;&nbsp;&nbsp;&nbsp;“标记-整理”算法过程与“标记-清理”算法一样，只是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉存活端边界以外的内存。

## 复制算法
&nbsp;&nbsp;&nbsp;&nbsp;“复制”算法将内存分为一块较大的Eden空间和两块较小的Survivior空间，HotSpot虚拟机默认将三者的比例分为8:1:1，每次新生代的可用内存空间为整个新生代容量的90%(80%+10%)。当产生垃圾收集动作时，虚拟机会将存活的对象复制到剩下的Survivior空间，然后把已使用过的内存空间一次清理掉，这样就不存在垃圾收集后空闲内存空间零散的情况；若回收后Survivior空间没有足够的空间存放上一次新生代收集下来的存活对象，就需要依赖其他内存(这里指老年代)进行**分配担保**。

---
# 对象已死？
&nbsp;&nbsp;&nbsp;&nbsp;在垃圾收集器对堆进行回收之前，第一件事情就是要确定这些对象之中哪些还“存活”，哪些已经“死去”（即不可能再被任何途径使用）。那么我们怎么判断对象是否“死去”了呢？

## 引用计数算法
&nbsp;&nbsp;&nbsp;&nbsp;该方法的实现原理是：给对象中添加一个引用计数器，每当一个地方引用它，计数器值加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就是不可能再被使用的。

&nbsp;&nbsp;&nbsp;&nbsp;然而，这种方法有一个问题：它很难解决对象之间相互循环引用的状况。举个例子：这里有对象A和对象B，有赋值令A.instance = B 及 B.instance = A，除此之外，再无任何引用。实际上这两个对象都不可能再被访问，但是因为它们互相引用着对方，使得引用计数器不为0，于是无法通知GC收集器回收它们。

## 可达性分析算法
&nbsp;&nbsp;&nbsp;&nbsp;在主流的商用程序语言的主流实现中，都是称通过**可达性分析**（Reachability Analysis）来判断对象是否是存活的。

&nbsp;&nbsp;&nbsp;&nbsp;这个算法的基本思路就是通过一系列的称为“**GC Roots**”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链**（Reference Chain），当一个对象没有任何引用链相连时，则证明此对象是不可用的。

&nbsp;&nbsp;&nbsp;&nbsp;在Java语言中，可作为GC Roots的对象包括以下4种：<br>
&nbsp;&nbsp;&nbsp;&nbsp;1.虚拟机栈中引用的对象。<br>
&nbsp;&nbsp;&nbsp;&nbsp;2.方法区中类静态属性引用的对象。<br>
&nbsp;&nbsp;&nbsp;&nbsp;3.方法区中常量引用的对象。<br>
&nbsp;&nbsp;&nbsp;&nbsp;4.本地方法栈中JNI（即一般的Native方法）引用的对象。<br>


---
# 引用问题
&nbsp;&nbsp;&nbsp;&nbsp;在 JDK1.2 之后，Java将引用分为了**强引用**、**软引用**、**弱引用**和**虚引用**4种，这4种引用强度依次逐渐减弱。下面简单介绍下这4种引用。

## 强引用
&nbsp;&nbsp;&nbsp;&nbsp;强引用是最普遍的引用，类似于“Object a = new Object()”这样。如果一个对象具有强引用，那么垃圾收集器宁愿抛出 OutOfMemoryError 错误也绝对不会回收它。

## 软引用
&nbsp;&nbsp;&nbsp;&nbsp;软引用是一些还有用但并非必需的对象。软引用会在内存空间不足时进行回收，软引用可以用来实现内存敏感的高速缓存。如果软引用被回收之后还是没有足够的内存，就会抛出内存溢出异常。

## 弱引用
&nbsp;&nbsp;&nbsp;&nbsp;弱引用跟软引用差不多，但是它的生命周期更短，在弱引用被垃圾收集器发现之后，不管内存够不够，都会被下一次的垃圾收集回收。

## 虚引用
&nbsp;&nbsp;&nbsp;&nbsp;虚引用是最弱的一种引用关系，如果一个对象仅仅有一个虚引用，那么它和没有引用一样，随时都可能被垃圾收集器回收。设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。



---
# 各区垃圾收集方式
&nbsp;&nbsp;&nbsp;&nbsp;几条最普遍的内存分配规则，虚拟机根据对象存活周期的大小会将对象分配到相应的“年代区”：对象会优先在Eden区分配，大对象直接进入老年代，长期存活的对象将进入老年代（默认值为15，即垃圾收集15次之后依然存活），另外，当Survivior空间不够时，存活对象会通过分配担保机制进入老年代，class、常量等信息直接加载进永生代。

&nbsp;&nbsp;&nbsp;&nbsp;当前商业虚拟机的垃圾回收都采用“**分代收集**（Generational Collection）”算法，这种算法会根据各个年代的特点采用最适当的垃圾收集算法。在**新生代**中，每次垃圾收集时都发现有大批对象死去，只有少量存活，所以选用**复制**算法，只需要付出少量存活对象的复制成本就可以完成收集；而**老年代**因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“**标记-清理**”或者“**标记-整理**”算法进行回收。

---
转载请注明出处：[小Hang同学的博客](http://www.yhang6.com/)