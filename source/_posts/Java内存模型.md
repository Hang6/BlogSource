---
title: Java内存模型
date: 2017-09-12 09:08:53
tags:
- 内存交互
- 内存模型
- 主内存
- 工作内存
- 先行发生
comments: true
categories: 原创
---
&nbsp;&nbsp;&nbsp;&nbsp;Java内存模型的主要目标是定义程序中各个变量（实例字段、静态字段、数组元素）的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。


# 主内存与工作内存
&nbsp;&nbsp;&nbsp;&nbsp;Java内存模型规定了所有的变量都存储于**主内存（Main Memory）**。每条线程都有自己的**工作内存（Working Memory）**，线程的工作内存中保存了被该线程使用到的**变量的主内存拷贝**。线程对变量的所有操作（读取、赋值等）都**必须**在**工作内存**中进行，而不能直接读写主内存中的变量。
<!-- more -->

&nbsp;&nbsp;&nbsp;&nbsp;**注意：**

&nbsp;&nbsp;&nbsp;&nbsp;上文的**变量**包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享。

&nbsp;&nbsp;&nbsp;&nbsp;这里所讲的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本是没有关系的。

# 内存间的交互操作
&nbsp;&nbsp;&nbsp;&nbsp;关于主内存和工作内存间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之类的实现细节，Java内存模型定义了以下**8种操作**来完成，虚拟机实现时**必须保证**下面提及的**每一种操作**都是**原子的**、**不可再分的**（double、long类型在某些平台的load、store、read、write允许有例外）。

- **lock（锁定）：作用于主内存的变量**，它把一个变量标识为一条线程独占的状态。
- **read（读取）：作用于主内存的变量**，它把一个变量的值从主内存传输到线程的工作内存中，以便以后的load动作使用。
- **load（载入）：作用于工作内存的变量**，它把read操作从主内存得到的变量值放入工作内存的变量副本中。
- **use（使用）：作用于工作内存的变量**，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时将会执行这个操作。
- **assign（赋值）：作用于工作内存的变量**，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- **store（存储）：作用于工作内存的变量**，它把工作内存中一个变量的值传送到主内存中，以便以后的write操作使用。
- **write（写入）：作用于主内存的变量**，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
- **unlock（解锁）：作用于主内存变量**，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。


&nbsp;&nbsp;&nbsp;&nbsp;如果要把一个变量从主内存复制到工作内存，那就要**顺序执行**read和load操作，如果要把变量从工作内存同步回主内存，就要**顺序执行**store和write操作。注意：Java内存模型只要求顺序执行，没有保证是连续执行，如read a、read b、load a、load b是可以的。除此之外，Java内存模型还规定了在执行上述8种操作时**必须满足以下规则**：

1. 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
2. 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该改变同步回主内存。
3. 不允许一个无原因的（没有发生任何assign操作）把数据从线程的工作内存同步回内存中。
4. 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。
5. 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
6. 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量之前，需要重新执行load或assign操作初始化其变量的值。
7. 如果一个变量事先没有被lock锁定，那就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁定的变量。
8. 对一个变量执行unlock操作之前，必须先把变量同步回主内存中（执行store、write操作）。

# 对于volatile型变量的特殊规则
&nbsp;&nbsp;&nbsp;&nbsp;关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，当一个变量定义为volatile之后，他将具备两种特性：保证变量对所有的线程的可见性、禁止指令重排序优化。

## 保证变量对所有的线程的可见性
&nbsp;&nbsp;&nbsp;&nbsp;这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的：当线程1进行修改时，会导致线程2工作内存中缓存变量的缓存行无效，当线程2再次读取变量的值时会去主内存中读取。

&nbsp;&nbsp;&nbsp;&nbsp;由于Java里面的运算并非原子操作，所以volatile变量的运算在并发下是不安全的，例如运算num++，它其实分为三步：读取num的值，将num+1，写入最新的num的值。因此，在**不符合以下两条规则**的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性：

- 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
- 变量不需要与其他的状态变量共同参与不变约束。

## volatile变量禁止指令重排序优化
&nbsp;&nbsp;&nbsp;&nbsp;普通的变量仅仅会保证在该方法的执行过程中所有的依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致，而volatile变量将会禁止此情况发生。举个例子：

```
//x,y为非volatile变量
//flag为volatile变量

x = 2           //语句1
y = 1           //语句2
flag = true     //语句3
x = 3           //语句4
y = 0           //语句5
```
&nbsp;&nbsp;&nbsp;&nbsp;由于flag为volatile变量，所以在进行指令重排序时，不会将语句3放到语句1、2之前，不会将语句3放到语句4、5之后；但是语句1和2、语句3和4的执行顺序是不做保证的。

&nbsp;&nbsp;&nbsp;&nbsp;它是通过内存屏障和禁止重排序来实现的：
- 对volatile变量执行写操作时，会在写操作后加入一条store屏障指令
- 对volatile变量进行读操作时，会在读操作前加入一条load屏障执令

# 先行发生原则(happens-before)
&nbsp;&nbsp;&nbsp;&nbsp;**先行发生**时Java内存模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能够被操作B观察到，“影响”包括修改了内存中共享变量的值，发送了的消息，调用了方法等。**先行发生原则**是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一览子地解决**并发环境**下两个操作之间是否可能存在冲突的所有问题。

&nbsp;&nbsp;&nbsp;&nbsp;下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，他们就没有顺序性保障，虚拟机可以对它们随意的进行重排序。

- **程序次序规则（Program Order Rule）**：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写后面的操作。准确的说，应该是控制流顺序而不是代码顺序，因为还有分支、循环等结构。
- **管程锁定规则（Monitor Lock Rule）**：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是**同一个锁**，而“后面”是指**时间**上的先后顺序。
- **volatile变量规则（volatile Variable Rule）**：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”指**时间**上的先后顺序。
- **线程启动规则（Thread Start Rule）**：Thread对象的start()方法先行发生于此线程的每一个动作。
- **线程终止规则（Thread Termination Rule**）：线程中所有的操作都先行发生于对此线程终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。
- **线程中断规则（Thread Interruption Rule）**：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
- **对象终结规则（Finalizer Rule）**：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
- **传递性（Transitivity**）：如果A操作先行发生于B操作，B操作先行发生于C操作，那么A操作先行发生于C操作。

&nbsp;&nbsp;&nbsp;&nbsp;**注意**：时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们**衡量并发安全**问题的时候不要受到时间顺序的干扰，**一切必须以先行发生原则为准**。

---
转载请注明出处：[小Hang同学的博客](http://www.yhang6.com/) 